"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

var Document = require("./document");

var Field = require("./fields").field;

var Date = require("./fields").date;

var Amount = require("./fields").amount;

var Locale = require("./fields").locale;

var Orientation = require("./fields").orientation;

var Tax = require("./fields").tax;

var fs = require("fs").promises;

var _initFromScratch = new WeakSet();

var _initFromApiPrediction = new WeakSet();

var _checklist = new WeakSet();

var _taxesMatchTotal = new WeakSet();

var _reconstruct = new WeakSet();

var _reconstructTotalExclFromTCCAndTaxes = new WeakSet();

var _reconstructTotalTax = new WeakSet();

class Receipt extends Document {
  /**
   *  @param {Object} apiPrediction - Json parsed prediction from HTTP response
   *  @param {Input} input - Input object
   *  @param {Integer} pageNumber - Page number for multi pages pdf input
   *  @param {Object} locale - locale value for creating Receipt object from scratch
   *  @param {Object} totalIncl - total tax Included value for creating Receipt object from scratch
   *  @param {Object} date - date value for creating Receipt object from scratch
   *  @param {Object} category - category value for creating Receipt object from scratch
   *  @param {Object} merchantName - merchant name value for creating Receipt object from scratch
   *  @param {Object} time - time value for creating Receipt object from scratch
   *  @param {Object} taxes - taxes value for creating Receipt object from scratch
   *  @param {Object} orientation - orientation value for creating Receipt object from scratch
   *  @param {Object} totalTax - total taxes value for creating Receipt object from scratch
   *  @param {Object} totalExcl - total taxes excluded value for creating Receipt object from scratch
   */
  constructor(_ref) {
    var {
      apiPrediction: _apiPrediction = undefined,
      inputFile = undefined,
      locale: _locale = undefined,
      totalIncl: _totalIncl = undefined,
      date: _date = undefined,
      category: _category = undefined,
      merchantName: _merchantName = undefined,
      time: _time = undefined,
      taxes: _taxes = undefined,
      orientation: _orientation = undefined,
      totalTax: _totalTax = undefined,
      totalExcl: _totalExcl = undefined,
      pageNumber: _pageNumber = 0
    } = _ref;
    super(inputFile);

    _reconstructTotalTax.add(this);

    _reconstructTotalExclFromTCCAndTaxes.add(this);

    _reconstruct.add(this);

    _taxesMatchTotal.add(this);

    _checklist.add(this);

    _initFromApiPrediction.add(this);

    _initFromScratch.add(this);

    if (_apiPrediction === undefined) {
      _classPrivateMethodGet(this, _initFromScratch, _initFromScratch2).call(this, {
        locale: _locale,
        totalExcl: _totalExcl,
        totalIncl: _totalIncl,
        date: _date,
        category: _category,
        merchantName: _merchantName,
        time: _time,
        taxes: _taxes,
        orientation: _orientation,
        totalTax: _totalTax,
        pageNumber: _pageNumber
      });
    } else {
      _classPrivateMethodGet(this, _initFromApiPrediction, _initFromApiPrediction2).call(this, _apiPrediction, _pageNumber);
    }

    _classPrivateMethodGet(this, _checklist, _checklist2).call(this);

    _classPrivateMethodGet(this, _reconstruct, _reconstruct2).call(this);
  }

  toString() {
    return "\n    -----Receipt data-----\n    Filename: ".concat(this.filename, "\n    Total amount: ").concat(this.totalIncl.value, "\n    Date: ").concat(this.date.value, "\n    Category: ").concat(this.category.value, "\n    Time: ").concat(this.time.value, "\n    Merchant name: ").concat(this.merchantName.value, "\n    Taxes: ").concat(this.taxes.map(tax => tax.toString()).join(" - "), "\n    Total taxes: ").concat(this.totalTax.value, "\n    ");
  }

  static load(path) {
    return _asyncToGenerator(function* () {
      var file = fs.readFile(path);
      var args = JSON.parse(file);
      return new Receipt(_objectSpread({
        reconsctruted: true
      }, args));
    })();
  }
  /**
   * Call all check methods
   */


}

var _initFromScratch2 = function _initFromScratch2(_ref2) {
  var {
    locale,
    totalExcl,
    totalIncl,
    date,
    category,
    merchantName,
    time,
    taxes,
    orientation,
    totalTax,
    pageNumber
  } = _ref2;

  var constructPrediction = function constructPrediction(item) {
    return {
      prediction: {
        value: item
      },
      valueKey: "value",
      pageNumber
    };
  };

  this.locale = new Locale(constructPrediction(locale));
  this.totalIncl = new Amount(constructPrediction(totalIncl));
  this.date = new Date(constructPrediction(date));
  this.category = new Field(constructPrediction(category));
  this.merchantName = new Field(constructPrediction(merchantName));
  this.time = new Field(constructPrediction(time));

  if (taxes !== undefined) {
    this.taxes = [];

    for (var t of taxes) {
      this.taxes.push(new Tax({
        prediction: {
          value: t[0],
          rate: t[1]
        },
        pageNumber,
        valueKey: "value",
        rateKey: "rate"
      }));
    }
  }

  this.orientation = new Orientation(constructPrediction(orientation));
  this.totalTax = new Amount(constructPrediction(totalTax));
  this.totalExcl = new Amount(constructPrediction(totalExcl));
};

var _initFromApiPrediction2 = function _initFromApiPrediction2(apiPrediction, pageNumber) {
  this.words = [];
  this.locale = new Locale({
    prediction: apiPrediction.locale,
    pageNumber
  });
  this.totalIncl = new Amount({
    prediction: apiPrediction.total_incl,
    valueKey: "value",
    pageNumber
  });
  this.date = new Date({
    prediction: apiPrediction.date,
    valueKey: "value",
    pageNumber
  });
  this.category = new Field({
    prediction: apiPrediction.category,
    pageNumber
  });
  this.merchantName = new Field({
    prediction: apiPrediction.supplier,
    valueKey: "value",
    pageNumber
  });
  this.time = new Field({
    prediction: apiPrediction.time,
    valueKey: "value",
    pageNumber
  });
  this.taxes = apiPrediction.taxes.map(taxPrediction => new Tax({
    prediction: taxPrediction,
    pageNumber,
    valueKey: "value",
    rateKey: "rate",
    codeKey: "code"
  }));
  this.orientation = new Orientation({
    prediction: apiPrediction.orientation,
    pageNumber
  });
  this.totalTax = new Amount({
    prediction: {
      value: undefined,
      probability: 0
    },
    valueKey: "value",
    pageNumber
  });
  this.totalExcl = new Amount({
    prediction: {
      value: undefined,
      probability: 0
    },
    valueKey: "value",
    pageNumber
  });
  if ("mvision" in apiPrediction) this.words = apiPrediction.mvision;
};

var _checklist2 = function _checklist2() {
  this.checklist = {
    taxesMatchTotalIncl: _classPrivateMethodGet(this, _taxesMatchTotal, _taxesMatchTotal2).call(this)
  };
};

var _taxesMatchTotal2 = function _taxesMatchTotal2() {
  // Check taxes and total amount exist
  if (this.taxes.length === 0 || this.totalIncl.value == null) return false; // Reconstruct total_incl from taxes

  var totalVat = 0;
  var reconstructedTotal = 0;
  this.taxes.forEach(tax => {
    if (tax.value == null || !tax.rate) return false;
    totalVat += tax.value;
    reconstructedTotal += tax.value + 100 * tax.value / tax.rate;
  }); // Sanity check

  if (totalVat <= 0) return false; // Crate epsilon

  var eps = 1 / (100 * totalVat);

  if (this.totalIncl.value * (1 - eps) - 0.02 <= reconstructedTotal && reconstructedTotal <= this.totalIncl.value * (1 + eps) + 0.02) {
    this.taxes = this.taxes.map(tax => _objectSpread(_objectSpread({}, tax), {}, {
      probability: 1.0
    }));
    this.totalTax.probability = 1.0;
    this.totalIncl.probability = 1.0;
    return true;
  }

  return false;
};

var _reconstruct2 = function _reconstruct2() {
  _classPrivateMethodGet(this, _reconstructTotalExclFromTCCAndTaxes, _reconstructTotalExclFromTCCAndTaxes2).call(this);

  _classPrivateMethodGet(this, _reconstructTotalTax, _reconstructTotalTax2).call(this);
};

var _reconstructTotalExclFromTCCAndTaxes2 = function _reconstructTotalExclFromTCCAndTaxes2() {
  if (this.taxes.length && this.totalIncl.value != null) {
    var totalExcl = {
      value: this.totalIncl.value - Field.arraySum(this.taxes),
      probability: Field.arrayProbability(this.taxes) * this.totalIncl.probability
    };
    this.totalExcl = new Amount({
      prediction: totalExcl,
      valueKey: "value",
      reconstructed: true
    });
  }
};

var _reconstructTotalTax2 = function _reconstructTotalTax2() {
  if (this.taxes.length && this.totalTax.value == null) {
    var totalTax = {
      value: this.taxes.map(tax => tax.value || 0).reduce((a, b) => a + b, 0),
      probability: Field.arrayProbability(this.taxes)
    };
    if (totalTax.value > 0) this.totalTax = new Amount({
      prediction: totalTax,
      valueKey: "value",
      reconstructed: true
    });
  }
};

module.exports = Receipt;