"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

var Document = require("./document");

var Field = require("./fields").field;

var Date = require("./fields").date;

var Amount = require("./fields").amount;

var Locale = require("./fields").locale;

var Orientation = require("./fields").orientation;

var PaymentDetails = require("./fields").paymentDetails;

var Tax = require("./fields").tax;

var _initFromScratch = new WeakSet();

var _initFromApiPrediction = new WeakSet();

var _checklist = new WeakSet();

var _reconstruct = new WeakSet();

var _taxesMatchTotalIncl = new WeakSet();

var _taxesMatchTotalExcl = new WeakSet();

var _taxesPlusTotalExclMatchTotalIncl = new WeakSet();

var _reconstructTotalTax = new WeakSet();

var _reconstructTotalTaxFromTotals = new WeakSet();

var _reconstructTotalExcl = new WeakSet();

var _reconstructTotalIncl = new WeakSet();

class Invoice extends Document {
  /**
   *  @param {Object} apiPrediction - Json parsed prediction from HTTP response
   *  @param {Input} input - Input object
   *  @param {Integer} pageNumber - Page number for multi pages pdf input
   *  @param {Object} locale - locale value for creating Invoice object from scratch
   *  @param {Object} totalIncl - total tax included value for creating Invoice object from scratch
   *  @param {Object} totalExcl - total tax excluded value for creating Invoice object from scratch
   *  @param {Object} invoiceDate - invoice date value for creating Invoice object from scratch
   *  @param {Object} invoiceNumber - invoice number value for creating Invoice object from scratch
   *  @param {Object} taxes - taxes value for creating Invoice object from scratch
   *  @param {Object} supplier - supplier value for creating Invoice object from scratch
   *  @param {Object} paymentDetails - payment details value for creating Invoice object from scratch
   *  @param {Object} companyNumber - company number value for creating Invoice object from scratch
   *  @param {Object} vatNumber - vat number value for creating Invoice object from scratch
   *  @param {Object} orientation - orientation value for creating Invoice object from scratch
   *  @param {Object} totalTax - total tax value for creating Invoice object from scratch
   *  @param {Object} pageNumber - pageNumber for multi pages pdf input
   */
  constructor(_ref) {
    var {
      apiPrediction: _apiPrediction = undefined,
      inputFile = undefined,
      locale: _locale = undefined,
      totalIncl: _totalIncl = undefined,
      totalExcl: _totalExcl = undefined,
      invoiceDate: _invoiceDate = undefined,
      invoiceNumber: _invoiceNumber = undefined,
      dueDate: _dueDate = undefined,
      taxes: _taxes = undefined,
      supplier: _supplier = undefined,
      paymentDetails: _paymentDetails = undefined,
      companyNumber: _companyNumber = undefined,
      vatNumber: _vatNumber = undefined,
      orientation: _orientation = undefined,
      totalTax: _totalTax = undefined,
      pageNumber: _pageNumber = 0
    } = _ref;
    super(inputFile);

    _reconstructTotalIncl.add(this);

    _reconstructTotalExcl.add(this);

    _reconstructTotalTaxFromTotals.add(this);

    _reconstructTotalTax.add(this);

    _taxesPlusTotalExclMatchTotalIncl.add(this);

    _taxesMatchTotalExcl.add(this);

    _taxesMatchTotalIncl.add(this);

    _reconstruct.add(this);

    _checklist.add(this);

    _initFromApiPrediction.add(this);

    _initFromScratch.add(this);

    if (_apiPrediction === undefined) {
      _classPrivateMethodGet(this, _initFromScratch, _initFromScratch2).call(this, {
        locale: _locale,
        totalIncl: _totalIncl,
        totalExcl: _totalExcl,
        invoiceDate: _invoiceDate,
        invoiceNumber: _invoiceNumber,
        dueDate: _dueDate,
        taxes: _taxes,
        supplier: _supplier,
        paymentDetails: _paymentDetails,
        companyNumber: _companyNumber,
        vatNumber: _vatNumber,
        orientation: _orientation,
        pageNumber: _pageNumber,
        totalTax: _totalTax
      });
    } else {
      _classPrivateMethodGet(this, _initFromApiPrediction, _initFromApiPrediction2).call(this, _apiPrediction, _pageNumber);
    }

    _classPrivateMethodGet(this, _checklist, _checklist2).call(this);

    _classPrivateMethodGet(this, _reconstruct, _reconstruct2).call(this);
  }

  toString() {
    return "\n    -----Invoice data-----\n    Filename: ".concat(this.filename, "\n    Invoice number: ").concat(this.invoiceNumber.value, "\n    Total amount including taxes: ").concat(this.totalIncl.value, "\n    Total amount excluding taxes: ").concat(this.totalExcl.value, "\n    Invoice Date: ").concat(this.invoiceDate.value, "\n    Supplier name: ").concat(this.supplier.value, "\n    Taxes: ").concat(this.taxes.map(tax => tax.toString()).join(" - "), "\n    Total taxes: ").concat(this.totalTax.value, "\n    ");
  }

}

var _initFromScratch2 = function _initFromScratch2(_ref2) {
  var {
    locale,
    totalIncl,
    totalExcl,
    totalTax,
    invoiceDate,
    invoiceNumber,
    dueDate,
    taxes,
    supplier,
    paymentDetails,
    companyNumber,
    vatNumber,
    orientation,
    pageNumber
  } = _ref2;

  var constructPrediction = function constructPrediction(item) {
    return {
      prediction: {
        value: item
      },
      valueKey: "value",
      pageNumber
    };
  };

  this.locale = new Locale(constructPrediction(locale));
  this.totalIncl = new Amount(constructPrediction(totalIncl));
  this.totalExcl = new Amount(constructPrediction(totalExcl));
  this.totalTax = new Amount(constructPrediction(totalTax));
  this.date = new Date(constructPrediction(invoiceDate));
  this.invoiceDate = new Date(constructPrediction(invoiceDate));
  this.dueDate = new Date(constructPrediction(dueDate));
  this.supplier = new Field(constructPrediction(supplier));
  this.orientation = new Orientation(constructPrediction(orientation));
  this.invoiceNumber = new Field(constructPrediction(invoiceNumber));
  this.paymentDetails = new Field(constructPrediction(paymentDetails));
  this.companyNumber = new Field(constructPrediction(companyNumber));
  this.vatNumber = new Field(constructPrediction(vatNumber));

  if (taxes !== undefined) {
    this.taxes = [];

    for (var t of taxes) {
      this.taxes.push(new Tax({
        prediction: {
          value: t[0],
          rate: t[1]
        },
        pageNumber,
        valueKey: "value",
        rateKey: "rate"
      }));
    }
  }
};

var _initFromApiPrediction2 = function _initFromApiPrediction2(apiPrediction, pageNumber) {
  this.words = [];
  this.locale = new Locale({
    prediction: apiPrediction.locale,
    pageNumber
  });
  this.totalIncl = new Amount({
    prediction: apiPrediction.total_incl,
    valueKey: "value",
    pageNumber
  });
  this.totalTax = new Amount({
    prediction: {
      value: undefined,
      probability: 0.0
    },
    valueKey: "value",
    pageNumber
  });
  this.totalExcl = new Amount({
    prediction: apiPrediction.total_excl,
    valueKey: "value",
    pageNumber
  });
  this.date = new Date({
    prediction: apiPrediction.date,
    valueKey: "value",
    pageNumber
  });
  this.invoiceDate = new Date({
    prediction: apiPrediction.date,
    valueKey: "value",
    pageNumber
  });
  this.taxes = apiPrediction.taxes.map(function (taxPrediction) {
    return new Tax({
      prediction: taxPrediction,
      pageNumber,
      valueKey: "value",
      rateKey: "rate",
      codeKey: "code"
    });
  });
  this.orientation = new Orientation({
    prediction: apiPrediction.orientation,
    pageNumber
  });
  this.companyNumber = apiPrediction.company_registration.map(function (companyNumber) {
    return new Field({
      prediction: companyNumber,
      pageNumber,
      extraFields: ["type"]
    });
  });
  this.dueDate = new Date({
    prediction: apiPrediction.due_date,
    valueKey: "value",
    pageNumber
  });
  this.invoiceNumber = new Field({
    prediction: apiPrediction.invoice_number,
    pageNumber
  });
  this.supplier = new Field({
    prediction: apiPrediction.supplier,
    pageNumber
  });
  this.paymentDetails = apiPrediction.payment_details.map(function (paymentDetail) {
    return new PaymentDetails({
      prediction: paymentDetail,
      pageNumber
    });
  });
  if ("mvision" in apiPrediction) this.words = apiPrediction.mvision;
};

var _checklist2 = function _checklist2() {
  this.checklist = {
    taxesMatchTotalIncl: _classPrivateMethodGet(this, _taxesMatchTotalIncl, _taxesMatchTotalIncl2).call(this),
    taxesMatchTotalExcl: _classPrivateMethodGet(this, _taxesMatchTotalExcl, _taxesMatchTotalExcl2).call(this),
    taxesPlusTotalExclMatchTotalIncl: _classPrivateMethodGet(this, _taxesPlusTotalExclMatchTotalIncl, _taxesPlusTotalExclMatchTotalIncl2).call(this)
  };
};

var _reconstruct2 = function _reconstruct2() {
  _classPrivateMethodGet(this, _reconstructTotalTax, _reconstructTotalTax2).call(this);

  _classPrivateMethodGet(this, _reconstructTotalExcl, _reconstructTotalExcl2).call(this);

  _classPrivateMethodGet(this, _reconstructTotalIncl, _reconstructTotalIncl2).call(this);

  _classPrivateMethodGet(this, _reconstructTotalTaxFromTotals, _reconstructTotalTaxFromTotals2).call(this);
};

var _taxesMatchTotalIncl2 = function _taxesMatchTotalIncl2() {
  // Check taxes and total include exist
  if (this.taxes.length === 0 || this.totalIncl.value === undefined) return false; // Reconstruct totalIncl from taxes

  var totalVat = 0;
  var reconstructedTotal = 0;
  this.taxes.forEach(tax => {
    if (tax.value === undefined || !tax.rate) return false;
    totalVat += tax.value;
    reconstructedTotal += tax.value + 100 * tax.value / tax.rate;
  }); // Sanity check

  if (totalVat <= 0) return false; // Crate epsilon

  var eps = 1 / (100 * totalVat);

  if (this.totalIncl.value * (1 - eps) - 0.02 <= reconstructedTotal && reconstructedTotal <= this.totalIncl.value * (1 + eps) + 0.02) {
    this.taxes = this.taxes.map(tax => _objectSpread(_objectSpread({}, tax), {}, {
      probability: 1.0
    }));
    this.totalTax.probability = 1.0;
    this.totalIncl.probability = 1.0;
    return true;
  }

  return false;
};

var _taxesMatchTotalExcl2 = function _taxesMatchTotalExcl2() {
  // Check taxes and total amount exist
  if (this.taxes.length === 0 || this.totalExcl.value == null) return false; // Reconstruct total_incl from taxes

  var totalVat = 0;
  var reconstructedTotal = 0;
  this.taxes.forEach(tax => {
    if (tax.value == null || !tax.rate) return false;
    totalVat += tax.value;
    reconstructedTotal += 100 * tax.value / tax.rate;
  }); // Sanity check

  if (totalVat <= 0) return false; // Crate epsilon

  var eps = 1 / (100 * totalVat);

  if (this.totalExcl.value * (1 - eps) - 0.02 <= reconstructedTotal && reconstructedTotal <= this.totalExcl.value * (1 + eps) + 0.02) {
    this.taxes = this.taxes.map(tax => _objectSpread(_objectSpread({}, tax), {}, {
      probability: 1.0
    }));
    this.totalTax.probability = 1.0;
    this.totalExcl.probability = 1.0;
    return true;
  }

  return false;
};

var _taxesPlusTotalExclMatchTotalIncl2 = function _taxesPlusTotalExclMatchTotalIncl2() {
  if (this.totalExcl.value === undefined || this.taxes.length == 0 || this.totalIncl === undefined) return false;
  var totalVat = 0;
  this.taxes.forEach(tax => totalVat += tax.value);
  var reconstructedTotal = totalVat + this.totalExcl.value;
  if (totalVat <= 0) return false;

  if (this.totalIncl.value - 0.01 <= reconstructedTotal && reconstructedTotal <= this.totalIncl.value + 0.01) {
    this.taxes = this.taxes.map(tax => _objectSpread(_objectSpread({}, tax), {}, {
      probability: 1.0
    }));
    this.totalTax.probability = 1.0;
    this.totalIncl.probability = 1.0;
    return true;
  }

  return false;
};

var _reconstructTotalTax2 = function _reconstructTotalTax2() {
  if (this.taxes.length > 0) {
    var totalTax = {
      value: this.taxes.reduce((acc, tax) => {
        return tax.value !== undefined ? acc + tax.value : acc;
      }, 0),
      probability: Field.arrayProbability(this.taxes)
    };
    if (totalTax.value > 0) this.totalTax = new Amount({
      prediction: totalTax,
      valueKey: "value",
      reconstructed: true
    });
  }
};

var _reconstructTotalTaxFromTotals2 = function _reconstructTotalTaxFromTotals2() {
  if (this.totalTax.value === undefined && this.totalIncl.value > 0 && this.totalExcl.value > 0 && this.totalExcl.value <= this.totalIncl.value) {
    var totalTax = {
      value: this.totalIncl.value - this.totalExcl.value,
      probability: this.totalIncl.probability * this.totalExcl.probability
    };
    if (totalTax.value > 0) this.totalTax = new Amount({
      prediction: totalTax,
      valueKey: "value",
      reconstructed: true
    });
  }
};

var _reconstructTotalExcl2 = function _reconstructTotalExcl2() {
  if (this.taxes.length && this.totalIncl.value != null && this.totalExcl.value === undefined) {
    var totalExcl = {
      value: this.totalIncl.value - this.taxes.reduce((acc, tax) => {
        return tax.value !== undefined ? acc + tax.value : acc;
      }, 0),
      probability: Field.arrayProbability(this.taxes) * this.totalIncl.probability
    };
    this.totalExcl = new Amount({
      prediction: totalExcl,
      valueKey: "value",
      reconstructed: true
    });
  }
};

var _reconstructTotalIncl2 = function _reconstructTotalIncl2() {
  if (this.taxes.length && this.totalExcl.value != null && this.totalIncl.value === undefined) {
    var totalIncl = {
      value: this.totalExcl.value + this.taxes.reduce((acc, tax) => {
        return tax.value ? acc + tax.value : acc;
      }, 0.0),
      probability: Field.arrayProbability(this.taxes) * this.totalExcl.probability
    };
    this.totalIncl = new Amount({
      prediction: totalIncl,
      valueKey: "value",
      reconstructed: true
    });
  }
};

module.exports = Invoice;