"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fs = require("fs").promises;

var errorHandler = require("./errors/handler");

var path = require("path");

var {
  PDFDocument
} = require("pdf-lib");

class Input {
  /**
   * @param {(String | Buffer)} file - the file that will be read. Either path or base64 string, or a steam
   * @param {String} inputType - the type of input used in file ("base64", "path", "dummy").
   *                             NB: in case of base64 file, only jpeg file is supported
   *                             NB: dummy is only used for tests purposes
   * @param {String} filename - File name of the input
   * @param {Boolean} cut_pdf: Automatically reconstruct pdf with more than 4 pages
   * NB: Because of async calls, init() should be called after creating the object
   */
  constructor(_ref) {
    var {
      file,
      filename = undefined,
      inputType,
      allowCutPdf = true
    } = _ref;

    _defineProperty(this, "MIMETYPES", {
      png: "image/png",
      jpg: "image/jpg",
      jpeg: "image/jpeg",
      webp: "image/webp",
      pdf: "application/pdf"
    });

    _defineProperty(this, "ALLOWED_INPUT_TYPE", ["base64", "path", "stream", "dummy"]);

    _defineProperty(this, "CUT_PDF_SIZE", 5);

    // Check if inputType is valid
    if (!this.ALLOWED_INPUT_TYPE.includes(inputType)) {
      errorHandler.throw(new Error("The input type is invalid. It should be             ".concat(this.ALLOWED_INPUT_TYPE.toString())));
    }

    this.file = file;
    this.filename = filename;
    this.inputType = inputType;
    this.allowCutPdf = allowCutPdf;
  }

  init() {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (_this.inputType === "base64") _this.initBase64();else if (_this.inputType === "path") yield _this.initFile();else if (_this.inputType === "stream") yield _this.initStream();else _this.initDummy();
    })();
  }

  initBase64() {
    this.fileObject = this.file;
    this.filepath = undefined;
    this.fileExtension = undefined;
  }

  initFile() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.fileObject = yield fs.readFile(_this2.file);
      _this2.filepath = _this2.file;
      _this2.filename = _this2.filename || path.basename(_this2.file); // Check if file type is valid

      var filetype = _this2.filename.split(".").pop();

      if (!(filetype in _this2.MIMETYPES)) {
        errorHandler.throw(new Error("File type is not allowed. It must be ".concat(Object.keys(_this2.MIMETYPES).toString())));
      }

      _this2.fileExtension = _this2.MIMETYPES[filetype];

      if (_this2.fileExtension === "application/pdf" && _this2.allowCutPdf == true) {
        yield _this2.cutPdf();
      }
    })();
  }

  initStream() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.fileObject = _this3.file;
      _this3.filename = _this3.filename || "stream";
      _this3.filepath = undefined;
    })();
  }

  initDummy() {
    this.fileObject = "";
    this.filename = "";
    this.filepath = "";
    this.fileExtension = "";
  }
  /** Cut PDF if pages > 5 */


  cutPdf() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      // convert document to PDFDocument & cut CUT_PDF_SIZE - 1 first pages and last page
      var pdfDocument = yield PDFDocument.load(_this4.fileObject);
      var splitedPdfDocument = yield PDFDocument.create();
      var pdfLength = pdfDocument.getPageCount();
      if (pdfLength <= _this4.CUT_PDF_SIZE) return;
      var pagesNumbers = [...Array(_this4.CUT_PDF_SIZE - 1).keys(), pdfLength - 1];
      var pages = yield splitedPdfDocument.copyPages(pdfDocument, pagesNumbers);
      pages.forEach(page => splitedPdfDocument.addPage(page));
      var data = yield splitedPdfDocument.save();
      _this4.fileObject = Buffer.from(data);
    })();
  }

}

module.exports = Input;